## 기능 변경

<details>
  <summary>이메일 인증</summary>
  <div markdown="1">
    현재 이메일 인증 관련 데이터는 아래와 같이 DB에 저장한다.

| Column Name | Data Type | Constraints|
|--|--|--|
| id | BIGINT | PRIMARY KEY, AUTO_INCREMENT |
| userId | BIGINT | NOT NULL, UNIQUE |
| authCode | VARCHAR | NULLABLE|

이메일 인증 코드 부분에 문제점이 존재한다.    

## 문제점

- ###   데이터 유지가 필요한가?   

해당 데이터의 본질은 회원가입을 시점으로 일정 시간이 초과된 이후에는 필요하지 않게 된다. 하지만 현재 코드의 구성으로 보았을 때는 기능을 다 하고 나서 해당 데이터가 영구적으로 제거되는 것이 아닌 그댈 별 다른 조치없으 데이터 베이스에 자리를 차지하고 있다. 

- ###   데이터를 불러오거나 쓰기 작업에 유용한가?    

데이터는 데이터베이스 기반 저장소에 저장이 되고 있다. 이러한 상황에서 인증코드 발행과 기존 코드 변경이 일어나게 되는 작업이 빈번하게 발생하는 경우, 즉 쉽게 설명해서 대용량 트래픽 상황에서 해당 기능에 병목이 발생할 수 있다고 생각이 들었다.   


## 대안

- #### 메모리 캐시 기반 관리 (예: Ehcache, Caffeine)   
  해당 방법은 Application 계층에서 메모리에 인증코드를 저장하며, TTL을 설정하여 자동으로 삭제를 설정할 수 있다.    

  해당 방법의 장점으로는 어플리케이션과 밀접하게 동작이 가능하여 성능적인 면에서 속도가 빠르다는 점이 존재한다.    

  하지만 어플리케이션 재실행 시 데이터 유실이 발생하고, 여러 인스턴스를 사용하는 분산 환경에서는 데이터 일관성을 보장하기 힘들다.   

- #### 외부 서비스를 활용 (예: Firebase, Auth)   
  이는 외부에서 제공하는 인증 서비스를 이용하는 방법이다.    

  외부에서 제공하는 서비스를 이용을 하면 개인적인 기능 구현 측면에는 부담을 줄여준다는 큰 장점이 존재하고, 추가적으로 보안 및 확작성을 보장 할 수 있다는 장점이 존재한다.

  하지만 무엇보다 추기 비용이 증가 한다는 단점이 존재한다.

### Redis 선택   
  Redis는 메모리 기반의 데이터 저장소로 설계되어 있다. 또한 현재 기능 처럼 단기적으로 유요한 데이터를 TTL을 이용하여 자동으로 삭제할 수 있어 적합하다.    
  추가적으로 메모리에서 데이터를 읽고 쓰는 작업을 하기 때문에 데이터베이스를 이용하는 방법과 비교하여 성능이 월등하게 우수하다는 점이 있으며, Redis는 클러스터링과 수평 확장을 지원한다는 점으로 대용량 트래픽이 발생하더라도 안정적인 동작이 가능하다는 점이 있다.

  </div>
</details>

<details>
  <summary>라이브러리 배포</summary>
  <div markdown="1">

**모놀리식** 프로젝트를 도메인 기준으로 분리해 각각의 **마이크로 서비스(MSA)** 로 전환하는 과정에서 몇 가지 불편함이 발견되었다.    

일단 가장 먼저 발견한 부분은 공통적으로 사용되는 공통 유틸리티 클래스를 각각의 마이크로 서비스 내 작성을 해야 한다는 점이다. 만약 직접적으로 해당 코드파일을 복사하여 모든 서비스 내 붙여넣기 정도까지는 양보를 할 수 있었다. 하지만 공통 유틸리티 클래스에서 기존 코드에서 수정이나, 새로운 매서드 추가 등 기존과 달리 변경된 부분이 생기면 각각 수정을 해줘야 한다는 문제점이 대두되었다.   

이를 해결하기 위한 방법으로 당장 두가지 방법이 생각이 떠올랐다.    

#### 1. 유틸리티 기능을 제공하는 전용 서비스를 만들어 API로 호출하는 방식   
#### 2. 유틸리티 클래스를 별도의 라이브러리로 만들어 재사용하는 방식    

각 방법을 간단하게 비교를 해보았다.   
| 방법 |	장점 | 단점 |
|--|--|--|
|유틸리티 서비스(API화) | 1. 중앙에서 코드를 관리하므로 유지보수가 용이  <br> 2. 실시간으로 변경 사항 반영 가능	 | 1. 서비스 호출 시 네트워크 지연 발생 가능 <br> 2. 추가적인 API 설계 및 구현이 필요 |    
| 유틸리티 클래스 라이브러리화 | 1. 네트워크 호출 없이 빠른 로컬 사용 가능  <br> 2. 모든 서비스에서 동일한 코드로 일관성 유지	 | 1. 라이브러리 변경 시 재배포가 필요   <br> 2. 의존성 관리가 복잡해질 수 있음 |    

간단하게 장단점을 보았을 때, 해당 코드는 서비스 간 데이터 동기화나 실시간 처리가 필요하지 않는 단순 유틸리티에 가까우며, 변경 빈도가 많지 않기 때문에 라이브러리화가 적합하다고 생각이 되어서 라이브러리화로 변경을 했다.

  </div>
</details>